以下では、GitHub ActionsにOpenTelemetryを組み合わせて可観測性を高める「GitHub Actions OpenTelemetry」について、ワークフローの課題や導入手順、具体的な活用事例などを順を追って紹介します。

---

# はじめに

GitHub Actionsは、リポジトリ内のコードをビルド・テスト・デプロイするCI/CDワークフローを手軽に構築できるサービスです。しかし、そのワークフローの詳細な可視化や、変更による効果測定には工夫が必要です。本ブログでは、OpenTelemetryを活用してGitHub Actionsの実行状況をトレース＆メトリクス化する「GitHub Actions OpenTelemetry」を紹介します。これにより、どのステップに時間がかかっているか、改善施策の効果がどの程度あったのかなどを把握しやすくなります。

---

# GitHub Actionsにおける課題

- **ワークフローの実行結果を視覚的に確認する方法が提供されていない**  
  ジョブが成功・失敗したことはわかりますが、具体的にどのステップがボトルネックになっているか、ワークフロー全体のどこに問題があるかは細かく把握しづらい状況です。

- **ワークフローの変更による影響を分析しづらい**  
  GitHubからは公式にActions metricsが提供されており、失敗率や平均実行時間といった情報は参照できます。しかし、ワークフローの改善によってどれだけ実行時間が短縮されたかなど、施策の効果を定量的に比較するためには平均時間以外の統計値（パーセンタイルなど）やステップ単位の可視化が必要となります。

  たとえば「ワークフローの変更前後で平均実行時間が短くなった」としても、それがどのステップに起因するのか、特定の条件下だけ時間が長引いているのか、といった詳細は標準機能だけでは掴みにくいのが課題です。

![alt text](image.png)

---

## 2. GitHub Actions OpenTelemetryとは？

### 概要と基本的な機能

「GitHub Actions OpenTelemetry」は、GitHub Actionsが完了したワークフローやジョブ、ステップごとにメトリクスやトレースを収集し、OpenTelemetry（OTLP）エンドポイントに送信する仕組みを提供します。主な機能は以下のとおりです。

- **メトリクス収集**: ワークフロー・ジョブの実行時間などを時系列で把握  
- **トレース収集**: どのステップがいつ開始・終了したか、どこでエラーが発生したかを可視化  
- **OTLP互換の監視ツールへの送信**: Jaeger、Prometheus、Grafana Tempoなど、お好みの観測ツールで分析可能

### OpenTelemetryの簡単な説明

OpenTelemetryは、CNCF (Cloud Native Computing Foundation) がホストする可観測性の標準フレームワークです。言語やプラットフォームに依存しない形でアプリケーションやサービスのメトリクス・トレース・ログを取得し、さまざまなバックエンドに送信するための仕組みが整備されています。GitHub Actions OpenTelemetryも、このOpenTelemetryの原則に則ってデータを収集・送信します。

### 導入するメリット

- **可視化とボトルネック把握**: ジョブやステップの実行状況を分散トレースやメトリクスとして見える化でき、遅延箇所の特定に役立つ  
- **改善施策の効果測定**: 改善前後の統計値を比較することで、具体的な時短効果や失敗率の低減を定量的に把握できる  
- **チームコラボレーション強化**: 視覚的なダッシュボードを共有することで、チーム全体でボトルネックや改善点を議論しやすい

---

## 3. 導入方法

GitHub Actions OpenTelemetryの導入は比較的シンプルで、下記のサンプルワークフローを参考に進められます。

1. **OTLPエンドポイントの準備**  
   まず、JaegerやPrometheusなどのOTLP互換バックエンドを用意しておき、テレメトリーデータを受信できる状態にします。  
2. **GitHub Actions Workflowの作成**  
   `workflow_run`イベントを使用し、完了したワークフローからメトリクスやトレースを収集するためのワークフローを新たに作成します。

### 最小限の設定とサンプルワークフロー

```yaml
name: Send Telemetry after Other Workflow

on:
  workflow_run:
    # 監視対象にしたいワークフロー名を指定
    workflows:
      - Check Transpiled JavaScript
      - Continuous Integration
      - CodeQL
      - Lint Codebase
    types:
      - completed

permissions:
  # プライベートリポジトリの場合に必要
  actions: read

jobs:
  send-telemetry:
    name: Send CI Telemetry
    runs-on: ubuntu-latest
    steps:
      - name: Run
        id: run
        uses: paper2/github-actions-opentelemetry@main
        env:
          OTEL_SERVICE_NAME: github-actions-opentelemetry
          OTEL_EXPORTER_OTLP_ENDPOINT: https://collector-example.com
          OTEL_EXPORTER_OTLP_HEADERS: api-key=${{ secrets.API_KEY }},other-config-value=value
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

このように設定すると、指定したワークフローが完了したタイミングで、自動的にその実行結果のメトリクスやトレース情報がOTLPエンドポイントに送られます。

---

## 4. 実際のユースケースと活用事例

### 開発現場での活用例

- **CI/CDパイプライン全体の可視化**: 大規模なモノレポ環境や複数サービスを抱える環境で、どのジョブがボトルネックになっているのかを一目で確認可能。  
- **複数ステップ間の依存関係を把握**: 依存ジョブが多い場合に、どこで待ちが発生しているかをトレース図で可視化しやすい。

### CI/CD改善における効果測定に活用
- **キャッシュ導入の効果計測**: ローカルのテストなどでビルドキャッシュが有効であると見込まれていても、実際の開発フローに組み込んだ場合の効果は異なる場合があります。OpenTelemetryで詳細に計測することで、導入前後で具体的に何秒（もしくは何％）短縮されたかを把握でき、さらに別サービスへの水平展開を検討する材料となります。  
- **小さく始める運用**: まずは一つのワークフローやサービスで測定を始め、効果を確認できたらmonorepoの他のサービスにも適用するといった段階的アプローチが取りやすいのもメリットです。

---

## 5. まとめと今後の展望

- **GitHub Actions OpenTelemetryを使うメリットの再整理**  
  1. ワークフロー全体の実行状況をトレース図やメトリクスとして可視化でき、ボトルネックやエラー箇所を特定しやすい。  
  2. 施策前後の効果測定が容易になり、改善の優先度付けやROIを定量的に示せる。  
  3. OTLP互換のツールと連携することで、自分好みの監視基盤にシームレスに統合可能。

- **今後期待されるアップデートや機能拡張**  
  - GitHub公式メトリクスとのさらなる統合や、より詳細なテレメトリーの標準提供が期待される。  
  - セットアップを簡略化するためのアクションやテンプレートの充実によって、導入ハードルが今後さらに下がる可能性がある。

- **読者への導入促進メッセージ**  
  GitHub Actionsの可視化や分析にお悩みの方は、ぜひ「GitHub Actions OpenTelemetry」を検討してみてください。ワークフローの詳細な可観測性が得られれば、問題の早期発見や高速な改善が実現し、開発効率やリリース品質が大きく向上するはずです。

以上が、GitHub Actions OpenTelemetryの概要と導入方法、さらに実際のユースケースまでを含めた紹介でした。ワークフローの現状を可視化し、より効率的な開発と高品質なリリースを目指す方の参考になれば幸いです。